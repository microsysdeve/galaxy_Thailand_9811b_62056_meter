 
#define API_EXT
#include "Include.h"

/*=========================================================================================\n
* @function_name: gCuc_BCD2HEXMap
* @function_file: Api.c
* @描述: BCD2HEX表
* 
* @参数: 
* @返回: 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
const uint8 code gCuc_BCD2HEXMap[]@0x300 =
{// 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, //0
    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, //1
    0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, //2
    0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, //3
    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, //4
    0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, //5
    0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, //6
    0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, //7
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, //8
    0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, //0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //9
};
/*=========================================================================================\n
* @function_name: gCuc_HEX2BCDMap
* @function_file: Api.c
* @描述: HEX2BCD表
* 
* @参数: 
* @返回: 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
const uint8 code gCuc_HEX2BCDMap[]@0x39c  =
{// 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, //0-9
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, //10-19
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, //20-29
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, //30-39
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, //40-49
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, //50-59
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, //60-69
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, //70-79
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, //80-89
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, //90-99
};
/*=========================================================================================\n
* @function_name: DelayXms
* @function_file: Api.c
* @描述: 13M pll下延时X MS
* 
* 
* @参数: 
* @param:num  MS数
* @返回: 
* @作者:   lwb (2012-05-27)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
void DelayXms(uint8 num)
{
    uint8 i,j;
    while(num--)
    {
        for(j=0;j<guc_PllSta;j++)                       //1MS  3.2m 32->8
        {
            for(i=0;i<20;i++)
            {
            
            }
        }
    }
}
/*=========================================================================================\n
* @function_name: Uint16_To_Uint8
* @function_file: Api.c
* @描述: 无符号整型数据转化成数组
* 
* 
* @参数: 
* @param:x      无符号整型数据
* @param:buff   转换后的数组
* @返回: 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
void Uint16_To_Uint8(uint16 x, uint8 * buff)
{
    buff[0] = x;
    buff[1] = x >> 8;
}
/*=========================================================================================\n
* @function_name: Uint8_To_Uint16
* @function_file: Api.c
* @描述: 
* 
* 
* @参数: 
* @param:buff  数组
* 
* @返回: 
* @return: uint16 转换后的无符号整型数据
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint16 Uint8_To_Uint16(uint8 * buff)
{
    return ((uint16)buff[1]<<8) + buff[0];
}

/*=========================================================================================\n
* @function_name: Uint24_To_Uint8
* @function_file: Api.c
* @描述: 无符号3字节数据转化成数组
* 
* 
* @参数: 
* @param:x      无符号3字节数据
* @param:buff  转换后的数组
* @返回: 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
void Uint24_To_Uint8(uint32 x, uint8 * buff)
{
    uint8* p = (uint8*)&x;

    *buff++ = *p++;
    *buff++ = *p++;
    *buff = *p;
}
/*=========================================================================================\n
* @function_name: Uint8_To_Uint24
* @function_file: Api.c
* @描述: 数组转化成无符号3字节数据
* 
* 
* @参数: 
* @param:buff  数组
* 
* @返回: 
* @return: uint32 转换后的无符号3字节数据
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint32 Uint8_To_Uint24(uint8 * buff)
{
    uint8* p;
    uint32 ulRet;

    p = (uint8*)&ulRet;
    *p++ = *buff++;
    *p++ = *buff++;
    *p++ = *buff++;
    *p = 0;

    return ulRet;
}
/*=========================================================================================\n
* @function_name: Uint32_To_Uint8
* @function_file: Api.c
* @描述: 无符号长整型转化成数组
* 
* 
* @参数: 
* @param:x     无符号长整型数据
* @param:buff  转换后的数组
* @返回: 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
void Uint32_To_Uint8(uint32 x, uint8 * buff)
{
    uint8 * data1;
    data1 = (uint8 *) &x;

    *buff++ = *data1++;
    *buff++ = *data1++;
    *buff++ = *data1++;
    *buff = *data1;
}
/*=========================================================================================\n
* @function_name: Int32_To_Uint8
* @function_file: Api.c
* @描述: 有符号长整型转化成数组
* 
* 
* @参数: 
* @param:x      有符号长整型数据
* @param:buff   转换后的数组
* @返回: 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
void Int32_To_Uint8(int32 x, uint8 * buff)
{
    uint8* p = (uint8*)&x;

    *buff++ = *p++;
    *buff++ = *p++;
    *buff++ = *p++;
    *buff = *p;
}
/*=========================================================================================\n
* @function_name: Uint8_To_Uint32
* @function_file: Api.c
* @描述: 数组转化成无符号长整型
* 
* 
* @参数: 
* @param:buff  数组
* 
* @返回: 
* @return: uint32 转换后的无符号长整型数据
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint32 Uint8_To_Uint32(uint8 * buff)
{
    uint8* p;
    uint32 ulRet;

    p = (uint8*)&ulRet;
    *p++ = *buff++;
    *p++ = *buff++;
    *p++ = *buff++;
    *p = *buff;

    return ulRet;
}

 
/*=========================================================================================\n
* @function_name: Uint8_To_Int32
* @function_file: Api.c
* @描述: 数组转化成有符号长整型
* 
* 
* @参数: 
* @param:buff  数组
* 
* @返回: 
* @return: int32 转换后的有符号长整型数据
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
int32 Uint8_To_Int32(uint8 * buff)
{
    return (int32)Uint8_To_Uint32(buff);
}
/*=========================================================================================\n
* @function_name: IntHex2BCD
* @function_file: Api.c
* @描述: 要转换的hex码(hex < 10000)
* 
* 
* @参数: 
* @param:hex  
* 
* @返回: 
* @return: uint16 将hex码转换成bcd之后的结果
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint16 IntHex2BCD(uint16 hex)
{
    uint16 result = 0;

    if(hex > 9999)
    {
        return 0xFFFF;
    }

    if(hex >= 8000)
    {
        result |= 0x8000;
        hex -= 8000;
    }

    if(hex >= 4000)
    {
        result |= 0x4000;
        hex -= 4000;
    }

    if(hex >= 2000)
    {
        result |= 0x2000;
        hex -= 2000;
    }

    if(hex >= 1000)
    {
        result |= 0x1000;
        hex -= 1000;
    }

    if(hex >= 800)
    {
        result |= 0x800;
        hex -= 800;
    }

    if(hex >= 400)
    {
        result |= 0x400;
        hex -= 400;
    }

    if(hex >= 200)
    {
        result |= 0x200;
        hex -= 200;
    }

    if(hex >= 100)
    {
        result |= 0x100;
        hex -= 100;
    }

    result |= APIByteHEX2BCD(hex);
    return result;

}
 
/*=========================================================================================\n
* @function_name: Hex2BCD
* @function_file: Api.c
* @描述: 要转换的hex码(hex < 100000000)
* 
* 
* @参数: 
* @param:hex  
* 
* @返回: 
* @return: uint32 将hex码转换成bcd之后的结果
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint32 Hex2BCD(uint32 hex)
{
    uint32 result = 0;
    uint32 cmp, bitcap;
    uint8 uc_i;

    while(hex > 99999999)
    {
        hex-=100000000;
        //return 0xFFFFFFFF;
    }

    for(cmp = 80000000, bitcap = 0x80000000, uc_i = 0; uc_i < 16; uc_i++)
    {
        if(hex >= cmp)
        {
            result |= bitcap;
            hex -= cmp;
        }
        bitcap >>= 1;
        switch(uc_i)
        {
            case 3:
                cmp = 8000000;
                break;
            case 7:
                cmp = 800000;
                break;
            case 11:
                cmp = 80000;
                break;
            default:
                cmp >>= 1;
        }
    }

    result |= IntHex2BCD(hex);
    return result;
}

 
/*=========================================================================================\n
* @function_name: BCD2Hex
* @function_file: Api.c
* @描述: 
* 
* 
* @参数: 
* @param:x  
* 
* @返回: 
* @return: uint32 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint32 BCD2Hex(uint32 x)
{
    uint8* p;
    uint32 ulRet = 0;

    p = (uint8*)&x + 3;
    for(uint8 i = 0; i < 4; i++)
    {
        ulRet *= 100;
        ulRet += APIByteBCD2HEX(*p--);
    }

    return ulRet;
}
 
/*=========================================================================================\n
* @function_name: IntBCD2Hex
* @function_file: Api.c
* @描述: 
* 
* 
* @参数: 
* @param:x  
* 
* @返回: 
* @return: uint16 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint16 IntBCD2Hex(uint16 x)
{
    return (100 * APIByteBCD2HEX(*((uint8*)&x + 1)) + APIByteBCD2HEX((uint8)(x & 0xFF)));
}
 
/*=========================================================================================\n
* @function_name: APIByteBCD2HEX
* @function_file: Api.c
* @描述: 
* 
* 
* @参数: 
* @param:ucBCD  
* 
* @返回: 
* @return: uint8 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint8 APIByteBCD2HEX(uint8 ucBCD)
{
    if(ucBCD > 0x99)
    {
        return 0xAA;
    }
    return gCuc_BCD2HEXMap[ucBCD];
}

/*=========================================================================================\n
* @function_name: APIByteHEX2BCD
* @function_file: Api.c
* @描述: 
* 
* 
* @参数: 
* @param:ucHEX  
* 
* @返回: 
* @return: uint8 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint8 APIByteHEX2BCD(uint8 ucHEX)
{
    if(ucHEX > 99)
    {
        return 0xFF;
    }
    return gCuc_HEX2BCDMap[ucHEX];
}
/*=========================================================================================\n
* @function_name: ApiBufCmp
* @function_file: Api.c
* @描述: 
* 
* 
* @参数: 
* @param:pucCompare     用于比较的缓存
* @param:pucCompared    被比较的缓存
* @param:ucLen          比较的长度
* 
* @返回: 
* @return: uint8    CMP_EQU: 两个缓存的内容一样
*                   CMP_LG: 两个缓存的内容不一样，pucCompare > pucCompared
*                   CMP_LT: 两个缓存的内容不一样，pucCompare < pucCompared
* @作者:   lwb (2012-02-29)
* @备注:            比较两个缓存里面的内容,从每个缓存的第一个字节开始比较,
*                   直到不一样之后退出,不一样的那两个字节的大小代表了两个缓存的大小.
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint8 ApiBufCmp(uint8* pucCompare, uint8* pucCompared, uint8 ucLen)
{   
    while(ucLen > 0)                        //循环，逐个字节的进行对比
    {
        ucLen --;                           //长度递减
                        
        if(*pucCompare !=  *pucCompared)    //比较
        {                                   //返回比较好的结果
            if(*pucCompare > *pucCompared)
            {
                return CMP_LG;
            }
            else
            {
                 return CMP_LT;
            }
        }
        pucCompare++;
        pucCompared++;
    }

    return CMP_EQU;
}
/*=========================================================================================\n
* @function_name: BufCmp
* @function_file: Multariff.c
* @描述: 比较缓冲中的数据，从尾部开始比较起
*
*
* @参数:
* @param:pucCompare
* @param:pucCompared
* @param:ucLen
*
* @返回:
* @return: uint8
* @作者:   lwb (2012-03-21)
* @备注:
*-------------------------------------------------------------------------------------------
* @修改人:
* @修改内容:
===========================================================================================*/
uint8 ApiRevBufCmp(uint8* pucCompare, uint8* pucCompared, uint8 ucLen)
{
    while(ucLen > 0)                                        //循环，逐个字节的进行对比
    {
        ucLen --;                                           //长度递减
        if(*(pucCompare+ucLen) !=  *(pucCompared+ucLen))    //比较
        {                                                   //返回比较好的结果
            if(*(pucCompare+ucLen) > *(pucCompared+ucLen))
            {
                return CMP_LG;
            }
            else
            {
                 return CMP_LT;
            }
        }
    }
    return CMP_EQU;
}

/*=========================================================================================\n
* @function_name: ApiCodeBufCmp
* @function_file: Api.c
* @描述: 
* 
* 
* @参数: 
* @param:pucCompare  用于比较的缓存
* @param:pucCompared  
* @param:ucLen  
* 
* @返回: 
* @return: uint8 
* @作者:   lwb (2012-05-28)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint8 ApiCodeBufCmp(uint8 code * pucCompare, const uint8 * pucCompared, uint8 ucLen)
{   
    while(ucLen > 0)                        //循环，逐个字节的进行对比
    {
        ucLen --;                           //长度递减
                        
        if(*pucCompare !=  *pucCompared)    //比较
        {                                   //返回比较好的结果
            if(*pucCompare > *pucCompared)
            {
                return CMP_LG;
            }
            else
            {
                 return CMP_LT;
            }
        }
        pucCompare++;
        pucCompared++;
    }

    return CMP_EQU;
}
/*=========================================================================================\n
* @function_name: ApiConData
* @function_file: Api.c
* @描述: 将数组里面的数翻转
* 
* 
* @参数: 
* @param:buff  
* @param:Len  
* @返回: 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
void ApiReverseData(uint8* buff, uint8 Len)
{
    udata8 temp;
    udata8 i;
    for(i=0;i<Len/2;i++)
    {
        temp=buff[i];
        buff[i]=*(buff+Len-1-i);
        *(buff+Len-1-i)=temp;
    }
}
/*=========================================================================================\n
* @function_name: CrcTab
* @function_file: Api.c
* @描述: X16+X12+X5+1 余式表
* 
* @参数: 
* @返回: 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
/* 
const uint16 code CrcTab[256] = {
    0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
    0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
    0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
    0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
    0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
    0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
    0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
    0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
    0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
    0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
    0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
    0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
    0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
    0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
    0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
    0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
    0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
    0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
    0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
    0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
    0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
    0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
    0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
    0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
    0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
    0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
    0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
    0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
    0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
    0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
    0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
    0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};

*/
const uint16 code CrcTab[256]@0x100={ // X16+X12+X5+1 余式表
    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
    0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
    0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
    0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
    0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
    0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
    0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
    0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
    0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
    0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
    0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
    0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
    0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
    0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
    0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
    0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
    0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
    0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
    0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
    0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
    0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
    0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
    0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
    0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
    0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
    0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
    0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
    0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
};
 
/*=========================================================================================\n
* @function_name: do_CRC
* @function_file: Api.c
* @描述: 做CRC校验
* 
* 
* @参数: 
* @param:data  数据地址
* @param:len  数据长度
* 
* @返回: 
* @return: uint16 CRC校验值
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint16 do_CRC(uint8 xdata *str,uint8 len)
{
/*  Word16 CrcCode;
    CrcCode.word=0;
    while(len--)
    {   
        CrcCode.word = (CrcCode.word >> 8) ^ CrcTab[(CrcCode.word ^(*(str++))) & 0xff];
    }
    return CrcCode.word;
*/
    uint8 ucData;
    uint16 crc;

    crc = 0x5555;

    for( ;len > 0; len--)
    {
        ucData = (uint8) (crc / 0x100);    //暂存crc高8位
        crc <<= 8;
        crc ^= CrcTab[ucData ^ (*str)];     //高字节和当前数据XOR再查表
        str++;
    }

    return crc;
}
 
/*=========================================================================================\n
* @function_name: JudgeIsNum
* @function_file: Api.c
* @描述: 对pucBuf所指的地址开始,总长度为ucLen内的所有字节进行BCD检验
* 
* 
* @参数: 
* @param:pucBuf  
* @param:ucLen  
* 
* @返回: 
* @return: uint8 如果全是符合BCD的返回Const_Data_OK,否则返回Const_Data_Err
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint8 JudgeIsNum(uint8* pucBuf, uint8 ucLen)
{//对pucBuf所指的地址开始,总长度为ucLen内的所有字节进行BCD检验,如果全是符合BCD的返回Const_Data_OK,否则返回Const_Data_Err
    while(ucLen--)
    {
        if(APIByteBCD2HEX(*pucBuf++) > 99)
        {
            return Const_Data_Err;
        }
    }
    return Const_Data_OK;
}

/*=========================================================================================\n
* @function_name: SumplementNegtive
* @function_file: Api.c
* @描述:    补充完负数据,用于短数据向long型数据扩充
*           比如说一个3字节的负数需要表示成long型的负数,那么long型数据的最高字节位0xff,
*           低三个字节为原来的三个字节
*           限制条件是ucLen在1-3之间
* @参数: 
* @param:ucLen  
* @param:p  
* @返回: 
* @作者:   lwb (2012-02-29)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
void SumplementNegtive(uint8 ucLen, uint8* p)
{
    if(ucLen == 0)
    {
        return;
    }

    if((ucLen == 3) && (*(p+2)&0x80))
    {
        *(p+3) = 0xff;
    }

    if((ucLen == 2) && (*(p+1)&0x80))
    {
        *(p+3) = 0xff;
        *(p+2) = 0xff;
    }

    if((ucLen == 1) && (*(p+0)&0x80))
    {
        *(p+3) = 0xff;
        *(p+2) = 0xff;
        *(p+1) = 0xff;
    }
}
/*=========================================================================================\n
* @function_name: MoveBuffer
* @function_file: Api.c
* @描述: 
* 
* 
* @参数: 
* @param:sbuff  源地址
* @param:tbuff  目标地址
* @param:length  移动的字节数（最大移动长度默认为256，可以在头文件中更改）
* @返回: 
* @作者:   lwb (2012-02-29)
* @备注:        将指定长度的字节从一个缓存转移到另外一个缓存，两个缓存的地址可以有重叠区。
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
void MoveBuffer(uint8* sbuff, uint8* tbuff, uint16 length)
{
                                            //先判断是否有正向移动重叠区域
    if((sbuff < tbuff) && (sbuff + length > tbuff))
    {                                       //有就从反向移动
        while(length != 0)                  //根据长度进行移动
        {
            length --;
            tbuff[length] = sbuff[length];  //移动
        }
    }
    else                                    //其它情况进行正向移动
    {
        while(length != 0)
        {
            length --;
            *tbuff++ = *sbuff++;            //移动
        }
    }
}
/*=========================================================================================\n
* @function_name: CompareTime
* @function_file: Api.c
* @描述: 比较当前时间和定时冻结时间的区别
*
*
* @参数:
* @param:Tm1  定时时间
* @param:Tm2  当前时间
*
* @返回:
* @return: uint8
* @作者:   lwb (2012-03-22)
* @备注:
*-------------------------------------------------------------------------------------------
* @修改人:
* @修改内容:
===========================================================================================*/
uint8 CompareTime(uint8  *Tm1,uint8 *Tm2)
{
    uint8 i;
    for(i=0;i<4;i++)
    {
        if(*(Tm1+i)==0x99)
        {
            continue;
        }

        if(*(Tm1+i)==*(Tm2+i))
        {
        }
        else
        {
            return false;
        }
    }
    return true;
}
/*=========================================================================================\n
* @function_name: MemInvertCpy
* @function_file: Api.c
* @描述: 反向拷贝数据
*
*
* @参数:
* @param:des 拷贝的目标地址
* @param:src 拷贝的源地址
* @param:len 数据长度
* @返回:
* @作者:   lwb (2012-04-05)
* @备注:
*-------------------------------------------------------------------------------------------
* @修改人:
* @修改内容:
===========================================================================================*/
void MemInvertC1py(uint8x *des,uint8x *src,uint8 len)
{
    while(len--)
    {
        *(des++)=*(src+len);
    }
}

/*=========================================================================================\n
* @function_name: FCpyTMem
* @function_file: Api.c
* @描述: 从Flash拷贝到RAM
* 
* 
* @参数: 
* @param:des  
* @param:src  
* @param:len  
* @返回: 
* @作者:   lwb (2012-05-24)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
//#pragma location = "BANK0"
//__banked_func 
/*
void FCpyTMem(uint8x *des,const uint8 code *src,uint8 len)
{
    while(len--)
    {
        *(des++)=*(src++);
    }
}

//#pragma location = "BANK1"
//__banked_func 
void FCpyTMem1(uint8x *des,const uint8 code *src,uint8 len)
{
    while(len--)
    {
        *(des++)=*(src++);
    }
}

//#pragma location = "BANK2"
//__banked_func 
void FCpyTMem2(uint8x *des,const uint8 code *src,uint8 len)
{
    while(len--)
    {
        *(des++)=*(src++);
    }
}
*/

/*=========================================================================================\n
* @function_name: MemCpy
* @function_file: Api.c
* @描述:
*
*
* @参数:
* @param:des
* @param:src
* @param:len
* @返回:
* @作者:   lwb (2012-04-05)
* @备注:
*-------------------------------------------------------------------------------------------
* @修改人:
* @修改内容:
===========================================================================================*/
void MemC1py(uint8x *des,uint8x *src,uint8 len)
{
    while(len--)
    {
        *(des++)=*(src++);
    }
}

/*=========================================================================================\n
* @function_name: MemSet
* @function_file: Api.c
* @描述:
*
*
* @参数:
* @param:des
* @param:value
* @param:len
* @返回:
* @作者:   lwb (2012-04-05)
* @备注:
*-------------------------------------------------------------------------------------------
* @修改人:
* @修改内容:
===========================================================================================*/
void MemSet(uint8x* des,uint8 value,uint8 len)
{
    while(len--)
    {
        *(des++)=value;
    }

}
/*=========================================================================================\n
* @function_name: CalCBRCount
* @function_file: Api.c
* @描述: 计算过了多少个抄表日
* 
* 
* @参数: 
* @param:str1  顺序是 分时日月年
* @param:str2  顺序是 分时日月年
* @param:ucDay  
* @param:ucHour  
* 
* @返回: 
* @return: uint8 
* @作者:   lwb (2012-06-07)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint8 CalCBRCount(uint8 xdata* str1,uint8 xdata* str2,uint8  ucDay,uint8  ucHour)
{
    int16 Count;
    Count=0;
    //          年          现在月      上次转存的月
    Count=(12*(APIByteBCD2HEX(*(str2+4))-APIByteBCD2HEX(*(str1+4))))+APIByteBCD2HEX(*(str2+3))-APIByteBCD2HEX(*(str1+3));     //月,上一年流下的月份加上当年的月份
    if(Count<0)
    {
        return 0;
    }
    //上次转存日期没过抄表日话，转存次数加1
    if((*(str1+2)<ucDay))
    {
        Count++;
    }else if((*(str1+2)==ucDay))
    {
        if(*(str1+1)<ucHour)
        {
            Count++;
        }
    }

    //现在 日没过抄表日话，转存次数减1
    if((*(str2+2)<ucDay))
    {
        if(Count>0)
        {
            Count--;
        }
    }else if((*(str2+2)==ucDay))
    {
        if((*(str2+1)<ucHour))
        {
            if(Count>0)
            {
                Count--;
            }
        }
    }

    return Count;
}
/*=========================================================================================\n
* @function_name: CalRDJCount
* @function_file: Api.c
* @描述: 计算过了多少日
* 
* 
* @参数: 
* @param:str1  顺序是 分时日月年
* @param:str2  顺序是 分时日月年
* @param:ucHour  
* @param:ucMin  
* 
* @返回: 
* @return: uint8 
* @作者:   lm (2012-12-19)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint8 CalRDJCount(uint8 xdata* str1,uint8 xdata* str2,uint8  ucHour,uint8  ucMin)
{
    int16 Count;
    uint8 uc_Maxday;
    Count=0;
    //                          现在年                    掉电年                      现在月                    掉电月
    Count=(12*(APIByteBCD2HEX(*(str2+4))-APIByteBCD2HEX(*(str1+4))))+APIByteBCD2HEX(*(str2+3))-APIByteBCD2HEX(*(str1+3));     //月,上一年流下的月份加上当年的月份
    if(Count<0)
    {
        return 0;
    }
    //如果大于1月，补7日
    if(Count>1)
    {
        Count=MAX_DayDJ;
    }
    else 
    {
        if(Count == 1) //如果等于1月，判断具体天数
        {
            uc_Maxday = MonthDays[*(str1+3)];                             //借鉴软时钟表格
            if(*(str1+3) == 0x02)
            {
                if((APIByteBCD2HEX(*(str1+4)) & 0x03) == 0)               // 闰年
                {
                    uc_Maxday++;                                        //闰年二月最大天数增加1
                }
            }
            Count=APIByteBCD2HEX(*(str2+2))+uc_Maxday-APIByteBCD2HEX(*(str1+2));
        }
        //         现在日         掉电日
        else  if((*(str2+2)) > (*(str1+2)))
        {
            Count = APIByteBCD2HEX(*(str2+2))-APIByteBCD2HEX(*(str1+2));
        }
        
        
        //    掉电时<日冻结时
        if(*(str1+1)<ucHour)
        {        
            Count++;            
        }
        //          掉电时 = 日冻结时    掉电分<日冻结分
        else if(((*(str1+1))==ucHour) && (*str1<ucMin))         
        {
            Count++;
        }
        
        //  现在时   日冻结时
        if(*(str2+1)<ucHour)
        {
          if(Count>0)
          {
            Count--;
          }
        }
        //          现在时 = 日冻结时    现在分>日冻结分
        else if(((*(str2+1))==ucHour) && (*str2<ucMin))         
        {
          if(Count>0)
          {
            Count--;
          }
        }  
    }
    if(Count>MAX_DayDJ)
    {
        Count=MAX_DayDJ;
    }

    return Count;
}
/*=========================================================================================\n
* @function_name: HourAndMinToMin
* @function_file: Api.c
* @描述: 
* 
* 
* @参数: 
* @param:Data  
* 
* @返回: 
* @return: uint16 
* @作者:   lwb (2012-06-15)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容: 
===========================================================================================*/
uint16 HourAndMinToMin(uint8*Data)
{
    return APIByteBCD2HEX(*Data)+APIByteBCD2HEX(*(Data+1))*60;
}


void FCpyTMe1m(uint8x *des,const uint8 code *src,uint8 len)
{
    while(len--)
    {
        *(des++)=*(src++);
    }
}


/*=========================================================================================\n
* @function_name: ASCII2BCD
* @function_file: Api.c
* @描述: 
* 
* 
* @参数： 
* @param:BCD     输出的BCD码
* @param:Ascii   输入ASCII
* @param:len     输入的ascii的长度
* 
* @返回： 
* @return: uint8   输出BCD码的长度
* @作者:  Lwb (2011-9-14)
* @备注: 
*-------------------------------------------------------------------------------------------
* @修改人:  
* @修改内容:  
===========================================================================================*/
uint8 ASCII2BCD(uint8*BCD,uint8*Ascii,uint8 len)
{
	uint8 i;
    for(i=0;i<len/2;i++)
    {
//      BCD[i]=(Ascii[i*2]-0x30)<<4;
//      BCD[i]|=((Ascii[i*2+1]-0x30)&0x0f);

        BCD[i]=(Ascii[len-i*2-2]-0x30)<<4;
        BCD[i]|=((Ascii[len-i*2-1]-0x30)&0x0f);
    }

    return len/2;  //传入的BCD码必须是偶数

//  if(len%2)                                   //len为奇数的时候
//  {
//      BCD[len/2]=((Ascii[len-1]-0x30)&0x0f);
//  }
//  return (len+1)/2;
}

/*=========================================================================================\n
* @function_name: BCD2ASCII
* @function_file: Api.c
* @描述: BCD 转 ASCII 码
* 
* @param: BCD   
* @param: Ascii  
* @param: len 
* 
* @return: uint8   
* @作者: lwb (2014/2/28)
* @备注:   
*-------------------------------------------------------------------------------------------
* @修改人: 
* @修改内容:  
===========================================================================================*/
uint8 BCD2ASCII(uint8*BCD,uint8*Ascii,uint8 len)
{
    uint8 AsciiLen=0;
	uint8 i;
    for(i=0;i<len;i++)
    {
        Ascii[AsciiLen++]=0x30+((BCD[len-1-i]&0xF0)>>4);
        Ascii[AsciiLen++]=0x30+(BCD[len-1-i]&0x0F);
    }
    return AsciiLen;
}
/*=========================================================================================\n
* @function_name: StrCpy
* @function_file: Api.c
* @描述:
*
*
* @参数:
* @param:des
* @param:src
* @param:len
* @返回:
* @作者:   lwb (2012-04-05)
* @备注:
*-------------------------------------------------------------------------------------------
* @修改人:
* @修改内容:
===========================================================================================*/
uint8 StrLen(const uint8 code *src)
{
    uint8 i,len;
    i=0;
    len=0;    
    while((src[i++]!='\0')
         &&(len<200))
    {
      len++;
    }
    
    return len;  
}
/*=========================================================================================\n
* @function_name: StrCpy
* @function_file: Api.c
* @描述:
*
*
* @参数:
* @param:des
* @param:src
* @返回:
* @作者:   lwb (2012-04-05)
* @备注:
*-------------------------------------------------------------------------------------------
* @修改人:
* @修改内容:
===========================================================================================*/
void StrCpy(uint8* des,const uint8 code *src)
{
    uint8 len;
    len=StrLen(src);
    CopyRam(des,(char *)src,len);
    return;
    while(len--)
    {
        *(des++)=*(src++);
    }
}